// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "Helpers/clone_const_reference.hpp"
#include "AtomIdxMapping.pypp.hpp"

namespace bp = boost::python;

#include "SireError/errors.h"

#include "SireID/index.h"

#include "SireMol/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "atomidxmapping.h"

#include "moleculeinfodata.h"

#include "atomidxmapping.h"

SireMol::AtomIdxMapping __copy__(const SireMol::AtomIdxMapping &other){ return SireMol::AtomIdxMapping(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_AtomIdxMapping_class(){

    { //::SireMol::AtomIdxMapping
        typedef bp::class_< SireMol::AtomIdxMapping, bp::bases< SireBase::Property > > AtomIdxMapping_exposer_t;
        AtomIdxMapping_exposer_t AtomIdxMapping_exposer = AtomIdxMapping_exposer_t( "AtomIdxMapping", "This class holds the mapping from one set of atom indices to another.\nThis enables you to associate, atom by atom, atom indices in one set to\natom indices in another set. This is useful, e.g. for building perturbations,\nor for specifying mappings for alignments or RMSD calculations etc.\n\nThis is mainly designed to provide sufficient information to merge\nproperties together. It lists not just the atoms that map, but\nalso which atoms are the ghost atoms that map (i.e. were created\nas ghost equivalents)\n", bp::init< >("Null constructor") );
        bp::scope AtomIdxMapping_scope( AtomIdxMapping_exposer );
        AtomIdxMapping_exposer.def( bp::init< SireMol::AtomIdxMappingEntry const & >(( bp::arg("entry") ), "Construct from a single entry") );
        AtomIdxMapping_exposer.def( bp::init< QList< SireMol::AtomIdxMappingEntry > const & >(( bp::arg("entries") ), "Construct from a list of entries") );
        AtomIdxMapping_exposer.def( bp::init< SireMol::AtomIdxMapping const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireMol::AtomIdxMapping::append
        
            typedef void ( ::SireMol::AtomIdxMapping::*append_function_type)( ::SireMol::AtomIdxMappingEntry const & ) ;
            append_function_type append_function_value( &::SireMol::AtomIdxMapping::append );
            
            AtomIdxMapping_exposer.def( 
                "append"
                , append_function_value
                , ( bp::arg("entry") )
                , bp::release_gil_policy()
                , "Append an entry to the list" );
        
        }
        { //::SireMol::AtomIdxMapping::append
        
            typedef void ( ::SireMol::AtomIdxMapping::*append_function_type)( ::SireMol::AtomIdxMapping const & ) ;
            append_function_type append_function_value( &::SireMol::AtomIdxMapping::append );
            
            AtomIdxMapping_exposer.def( 
                "append"
                , append_function_value
                , ( bp::arg("other") )
                , bp::release_gil_policy()
                , "Append all of the passed entries of other onto this list" );
        
        }
        { //::SireMol::AtomIdxMapping::clear
        
            typedef void ( ::SireMol::AtomIdxMapping::*clear_function_type)(  ) ;
            clear_function_type clear_function_value( &::SireMol::AtomIdxMapping::clear );
            
            AtomIdxMapping_exposer.def( 
                "clear"
                , clear_function_value
                , bp::release_gil_policy()
                , "Clear the list" );
        
        }
        { //::SireMol::AtomIdxMapping::count
        
            typedef int ( ::SireMol::AtomIdxMapping::*count_function_type)(  ) const;
            count_function_type count_function_value( &::SireMol::AtomIdxMapping::count );
            
            AtomIdxMapping_exposer.def( 
                "count"
                , count_function_value
                , bp::release_gil_policy()
                , "Return the count of the list" );
        
        }
        { //::SireMol::AtomIdxMapping::isEmpty
        
            typedef bool ( ::SireMol::AtomIdxMapping::*isEmpty_function_type)(  ) const;
            isEmpty_function_type isEmpty_function_value( &::SireMol::AtomIdxMapping::isEmpty );
            
            AtomIdxMapping_exposer.def( 
                "isEmpty"
                , isEmpty_function_value
                , bp::release_gil_policy()
                , "Return whether or not the list is empty" );
        
        }
        AtomIdxMapping_exposer.def( bp::self != bp::self );
        AtomIdxMapping_exposer.def( bp::self + bp::self );
        AtomIdxMapping_exposer.def( bp::self + bp::other< SireMol::AtomIdxMappingEntry >() );
        { //::SireMol::AtomIdxMapping::operator=
        
            typedef ::SireMol::AtomIdxMapping & ( ::SireMol::AtomIdxMapping::*assign_function_type)( ::SireMol::AtomIdxMapping const & ) ;
            assign_function_type assign_function_value( &::SireMol::AtomIdxMapping::operator= );
            
            AtomIdxMapping_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        AtomIdxMapping_exposer.def( bp::self == bp::self );
        { //::SireMol::AtomIdxMapping::operator[]
        
            typedef ::SireMol::AtomIdxMappingEntry const & ( ::SireMol::AtomIdxMapping::*__getitem___function_type)( int ) const;
            __getitem___function_type __getitem___function_value( &::SireMol::AtomIdxMapping::operator[] );
            
            AtomIdxMapping_exposer.def( 
                "__getitem__"
                , __getitem___function_value
                , ( bp::arg("i") )
                , bp::return_value_policy<bp::clone_const_reference, bp::release_gil_policy>()
                , "" );
        
        }
        { //::SireMol::AtomIdxMapping::remove
        
            typedef void ( ::SireMol::AtomIdxMapping::*remove_function_type)( int ) ;
            remove_function_type remove_function_value( &::SireMol::AtomIdxMapping::remove );
            
            AtomIdxMapping_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Remove the entry at index i" );
        
        }
        { //::SireMol::AtomIdxMapping::remove
        
            typedef void ( ::SireMol::AtomIdxMapping::*remove_function_type)( ::SireMol::AtomIdx const & ) ;
            remove_function_type remove_function_value( &::SireMol::AtomIdxMapping::remove );
            
            AtomIdxMapping_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Remove the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::remove
        
            typedef void ( ::SireMol::AtomIdxMapping::*remove_function_type)( ::SireMol::CGAtomIdx const & ) ;
            remove_function_type remove_function_value( &::SireMol::AtomIdxMapping::remove );
            
            AtomIdxMapping_exposer.def( 
                "remove"
                , remove_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Remove the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::size
        
            typedef int ( ::SireMol::AtomIdxMapping::*size_function_type)(  ) const;
            size_function_type size_function_value( &::SireMol::AtomIdxMapping::size );
            
            AtomIdxMapping_exposer.def( 
                "size"
                , size_function_value
                , bp::release_gil_policy()
                , "Return the size of the list" );
        
        }
        { //::SireMol::AtomIdxMapping::take
        
            typedef ::SireMol::AtomIdxMappingEntry ( ::SireMol::AtomIdxMapping::*take_function_type)( int ) ;
            take_function_type take_function_value( &::SireMol::AtomIdxMapping::take );
            
            AtomIdxMapping_exposer.def( 
                "take"
                , take_function_value
                , ( bp::arg("i") )
                , bp::release_gil_policy()
                , "Take the entry at index i" );
        
        }
        { //::SireMol::AtomIdxMapping::take
        
            typedef ::SireMol::AtomIdxMappingEntry ( ::SireMol::AtomIdxMapping::*take_function_type)( ::SireMol::AtomIdx const & ) ;
            take_function_type take_function_value( &::SireMol::AtomIdxMapping::take );
            
            AtomIdxMapping_exposer.def( 
                "take"
                , take_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Take the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::take
        
            typedef ::SireMol::AtomIdxMappingEntry ( ::SireMol::AtomIdxMapping::*take_function_type)( ::SireMol::CGAtomIdx const & ) ;
            take_function_type take_function_value( &::SireMol::AtomIdxMapping::take );
            
            AtomIdxMapping_exposer.def( 
                "take"
                , take_function_value
                , ( bp::arg("atom") )
                , bp::release_gil_policy()
                , "Take the entry for atom atom" );
        
        }
        { //::SireMol::AtomIdxMapping::toString
        
            typedef ::QString ( ::SireMol::AtomIdxMapping::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireMol::AtomIdxMapping::toString );
            
            AtomIdxMapping_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Convert this object to a string" );
        
        }
        { //::SireMol::AtomIdxMapping::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireMol::AtomIdxMapping::typeName );
            
            AtomIdxMapping_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireMol::AtomIdxMapping::what
        
            typedef char const * ( ::SireMol::AtomIdxMapping::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireMol::AtomIdxMapping::what );
            
            AtomIdxMapping_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        AtomIdxMapping_exposer.staticmethod( "typeName" );
        AtomIdxMapping_exposer.def( "__copy__", &__copy__);
        AtomIdxMapping_exposer.def( "__deepcopy__", &__copy__);
        AtomIdxMapping_exposer.def( "clone", &__copy__);
        AtomIdxMapping_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireMol::AtomIdxMapping >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomIdxMapping_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireMol::AtomIdxMapping >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        AtomIdxMapping_exposer.def_pickle(sire_pickle_suite< ::SireMol::AtomIdxMapping >());
        AtomIdxMapping_exposer.def( "__str__", &__str__< ::SireMol::AtomIdxMapping > );
        AtomIdxMapping_exposer.def( "__repr__", &__str__< ::SireMol::AtomIdxMapping > );
        AtomIdxMapping_exposer.def( "__len__", &__len_size< ::SireMol::AtomIdxMapping > );
    }

}

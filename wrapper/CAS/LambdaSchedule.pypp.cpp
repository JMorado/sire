// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "LambdaSchedule.pypp.hpp"

namespace bp = boost::python;

#include "SireCAS/values.h"

#include "SireError/errors.h"

#include "SireStream/datastream.h"

#include "SireStream/shareddatastream.h"

#include "lambdaschedule.h"

#include "lambdaschedule.h"

SireCAS::LambdaSchedule __copy__(const SireCAS::LambdaSchedule &other){ return SireCAS::LambdaSchedule(other); }

#include "Qt/qdatastream.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

void register_LambdaSchedule_class(){

    { //::SireCAS::LambdaSchedule
        typedef bp::class_< SireCAS::LambdaSchedule, bp::bases< SireBase::Property > > LambdaSchedule_exposer_t;
        LambdaSchedule_exposer_t LambdaSchedule_exposer = LambdaSchedule_exposer_t( "LambdaSchedule", "This is a schedule that specifies how parameters are changed according\nto a global lambda value. The change can be broken up by sub lever,\nand by stage.\n", bp::init< >("") );
        bp::scope LambdaSchedule_scope( LambdaSchedule_exposer );
        LambdaSchedule_exposer.def( bp::init< SireCAS::LambdaSchedule const & >(( bp::arg("other") ), "") );
        { //::SireCAS::LambdaSchedule::addChargeScaleStages
        
            typedef void ( ::SireCAS::LambdaSchedule::*addChargeScaleStages_function_type)( double ) ;
            addChargeScaleStages_function_type addChargeScaleStages_function_value( &::SireCAS::LambdaSchedule::addChargeScaleStages );
            
            LambdaSchedule_exposer.def( 
                "addChargeScaleStages"
                , addChargeScaleStages_function_value
                , ( bp::arg("scale") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addLever
        
            typedef void ( ::SireCAS::LambdaSchedule::*addLever_function_type)( ::QString const & ) ;
            addLever_function_type addLever_function_value( &::SireCAS::LambdaSchedule::addLever );
            
            LambdaSchedule_exposer.def( 
                "addLever"
                , addLever_function_value
                , ( bp::arg("lever") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addLevers
        
            typedef void ( ::SireCAS::LambdaSchedule::*addLevers_function_type)( ::QStringList const & ) ;
            addLevers_function_type addLevers_function_value( &::SireCAS::LambdaSchedule::addLevers );
            
            LambdaSchedule_exposer.def( 
                "addLevers"
                , addLevers_function_value
                , ( bp::arg("levers") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addMorphStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addMorphStage_function_type)(  ) ;
            addMorphStage_function_type addMorphStage_function_value( &::SireCAS::LambdaSchedule::addMorphStage );
            
            LambdaSchedule_exposer.def( 
                "addMorphStage"
                , addMorphStage_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::addStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*addStage_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            addStage_function_type addStage_function_value( &::SireCAS::LambdaSchedule::addStage );
            
            LambdaSchedule_exposer.def( 
                "addStage"
                , addStage_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::appendStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*appendStage_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            appendStage_function_type appendStage_function_value( &::SireCAS::LambdaSchedule::appendStage );
            
            LambdaSchedule_exposer.def( 
                "appendStage"
                , appendStage_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::clamp
        
            typedef double ( ::SireCAS::LambdaSchedule::*clamp_function_type)( double ) const;
            clamp_function_type clamp_function_value( &::SireCAS::LambdaSchedule::clamp );
            
            LambdaSchedule_exposer.def( 
                "clamp"
                , clamp_function_value
                , ( bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "Clamp and return the passed lambda value so that it is between a valid\n  range for this schedule (typically between [0.0-1.0] inclusive).\n" );
        
        }
        { //::SireCAS::LambdaSchedule::clear
        
            typedef void ( ::SireCAS::LambdaSchedule::*clear_function_type)(  ) ;
            clear_function_type clear_function_value( &::SireCAS::LambdaSchedule::clear );
            
            LambdaSchedule_exposer.def( 
                "clear"
                , clear_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::final
        
            typedef ::SireCAS::Symbol ( *final_function_type )(  );
            final_function_type final_function_value( &::SireCAS::LambdaSchedule::final );
            
            LambdaSchedule_exposer.def( 
                "final"
                , final_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getConstant
        
            typedef double ( ::SireCAS::LambdaSchedule::*getConstant_function_type)( ::QString const & ) ;
            getConstant_function_type getConstant_function_value( &::SireCAS::LambdaSchedule::getConstant );
            
            LambdaSchedule_exposer.def( 
                "getConstant"
                , getConstant_function_value
                , ( bp::arg("constant") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getConstant
        
            typedef double ( ::SireCAS::LambdaSchedule::*getConstant_function_type)( ::SireCAS::Symbol const & ) const;
            getConstant_function_type getConstant_function_value( &::SireCAS::LambdaSchedule::getConstant );
            
            LambdaSchedule_exposer.def( 
                "getConstant"
                , getConstant_function_value
                , ( bp::arg("constant") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getConstantSymbol
        
            typedef ::SireCAS::Symbol ( ::SireCAS::LambdaSchedule::*getConstantSymbol_function_type)( ::QString const & ) const;
            getConstantSymbol_function_type getConstantSymbol_function_value( &::SireCAS::LambdaSchedule::getConstantSymbol );
            
            LambdaSchedule_exposer.def( 
                "getConstantSymbol"
                , getConstantSymbol_function_value
                , ( bp::arg("constant") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getEquation
        
            typedef ::SireCAS::Expression ( ::SireCAS::LambdaSchedule::*getEquation_function_type)( ::QString const & ) const;
            getEquation_function_type getEquation_function_value( &::SireCAS::LambdaSchedule::getEquation );
            
            LambdaSchedule_exposer.def( 
                "getEquation"
                , getEquation_function_value
                , ( bp::arg("stage") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getEquation
        
            typedef ::SireCAS::Expression ( ::SireCAS::LambdaSchedule::*getEquation_function_type)( ::QString const &,::QString const & ) const;
            getEquation_function_type getEquation_function_value( &::SireCAS::LambdaSchedule::getEquation );
            
            LambdaSchedule_exposer.def( 
                "getEquation"
                , getEquation_function_value
                , ( bp::arg("stage"), bp::arg("lever") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLambdaInStage
        
            typedef double ( ::SireCAS::LambdaSchedule::*getLambdaInStage_function_type)( double ) const;
            getLambdaInStage_function_type getLambdaInStage_function_value( &::SireCAS::LambdaSchedule::getLambdaInStage );
            
            LambdaSchedule_exposer.def( 
                "getLambdaInStage"
                , getLambdaInStage_function_value
                , ( bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverStages
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getLeverStages_function_type)( ::QVector< double > const & ) const;
            getLeverStages_function_type getLeverStages_function_value( &::SireCAS::LambdaSchedule::getLeverStages );
            
            LambdaSchedule_exposer.def( 
                "getLeverStages"
                , getLeverStages_function_value
                , ( bp::arg("lambda_values") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverStages
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getLeverStages_function_type)( int ) const;
            getLeverStages_function_type getLeverStages_function_value( &::SireCAS::LambdaSchedule::getLeverStages );
            
            LambdaSchedule_exposer.def( 
                "getLeverStages"
                , getLeverStages_function_value
                , ( bp::arg("num_lambda")=(int)(101) )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverValues
        
            typedef ::QHash< QString, QVector< double > > ( ::SireCAS::LambdaSchedule::*getLeverValues_function_type)( ::QVector< double > const &,double,double ) const;
            getLeverValues_function_type getLeverValues_function_value( &::SireCAS::LambdaSchedule::getLeverValues );
            
            LambdaSchedule_exposer.def( 
                "getLeverValues"
                , getLeverValues_function_value
                , ( bp::arg("lambda_values"), bp::arg("initial")=1., bp::arg("final")=2. )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLeverValues
        
            typedef ::QHash< QString, QVector< double > > ( ::SireCAS::LambdaSchedule::*getLeverValues_function_type)( int,double,double ) const;
            getLeverValues_function_type getLeverValues_function_value( &::SireCAS::LambdaSchedule::getLeverValues );
            
            LambdaSchedule_exposer.def( 
                "getLeverValues"
                , getLeverValues_function_value
                , ( bp::arg("num_lambda")=(int)(101), bp::arg("initial")=1., bp::arg("final")=2. )
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getLevers
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getLevers_function_type)(  ) const;
            getLevers_function_type getLevers_function_value( &::SireCAS::LambdaSchedule::getLevers );
            
            LambdaSchedule_exposer.def( 
                "getLevers"
                , getLevers_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getStage
        
            typedef ::QString ( ::SireCAS::LambdaSchedule::*getStage_function_type)( double ) const;
            getStage_function_type getStage_function_value( &::SireCAS::LambdaSchedule::getStage );
            
            LambdaSchedule_exposer.def( 
                "getStage"
                , getStage_function_value
                , ( bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::getStages
        
            typedef ::QStringList ( ::SireCAS::LambdaSchedule::*getStages_function_type)(  ) const;
            getStages_function_type getStages_function_value( &::SireCAS::LambdaSchedule::getStages );
            
            LambdaSchedule_exposer.def( 
                "getStages"
                , getStages_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::initial
        
            typedef ::SireCAS::Symbol ( *initial_function_type )(  );
            initial_function_type initial_function_value( &::SireCAS::LambdaSchedule::initial );
            
            LambdaSchedule_exposer.def( 
                "initial"
                , initial_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::insertStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*insertStage_function_type)( int,::QString const &,::SireCAS::Expression const & ) ;
            insertStage_function_type insertStage_function_value( &::SireCAS::LambdaSchedule::insertStage );
            
            LambdaSchedule_exposer.def( 
                "insertStage"
                , insertStage_function_value
                , ( bp::arg("i"), bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::isNull
        
            typedef bool ( ::SireCAS::LambdaSchedule::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireCAS::LambdaSchedule::isNull );
            
            LambdaSchedule_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::lam
        
            typedef ::SireCAS::Symbol ( *lam_function_type )(  );
            lam_function_type lam_function_value( &::SireCAS::LambdaSchedule::lam );
            
            LambdaSchedule_exposer.def( 
                "lam"
                , lam_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::morph
        
            typedef ::QVector< double > ( ::SireCAS::LambdaSchedule::*morph_function_type)( ::QString const &,::QVector< double > const &,::QVector< double > const &,double ) const;
            morph_function_type morph_function_value( &::SireCAS::LambdaSchedule::morph );
            
            LambdaSchedule_exposer.def( 
                "morph"
                , morph_function_value
                , ( bp::arg("lever"), bp::arg("initial"), bp::arg("final"), bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::morph
        
            typedef ::QVector< int > ( ::SireCAS::LambdaSchedule::*morph_function_type)( ::QString const &,::QVector< int > const &,::QVector< int > const &,double ) const;
            morph_function_type morph_function_value( &::SireCAS::LambdaSchedule::morph );
            
            LambdaSchedule_exposer.def( 
                "morph"
                , morph_function_value
                , ( bp::arg("lever"), bp::arg("initial"), bp::arg("final"), bp::arg("lambda_value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::nLevers
        
            typedef int ( ::SireCAS::LambdaSchedule::*nLevers_function_type)(  ) const;
            nLevers_function_type nLevers_function_value( &::SireCAS::LambdaSchedule::nLevers );
            
            LambdaSchedule_exposer.def( 
                "nLevers"
                , nLevers_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::nStages
        
            typedef int ( ::SireCAS::LambdaSchedule::*nStages_function_type)(  ) const;
            nStages_function_type nStages_function_value( &::SireCAS::LambdaSchedule::nStages );
            
            LambdaSchedule_exposer.def( 
                "nStages"
                , nStages_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        LambdaSchedule_exposer.def( bp::self != bp::self );
        { //::SireCAS::LambdaSchedule::operator=
        
            typedef ::SireCAS::LambdaSchedule & ( ::SireCAS::LambdaSchedule::*assign_function_type)( ::SireCAS::LambdaSchedule const & ) ;
            assign_function_type assign_function_value( &::SireCAS::LambdaSchedule::operator= );
            
            LambdaSchedule_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        LambdaSchedule_exposer.def( bp::self == bp::self );
        { //::SireCAS::LambdaSchedule::prependStage
        
            typedef void ( ::SireCAS::LambdaSchedule::*prependStage_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            prependStage_function_type prependStage_function_value( &::SireCAS::LambdaSchedule::prependStage );
            
            LambdaSchedule_exposer.def( 
                "prependStage"
                , prependStage_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeEquation
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeEquation_function_type)( ::QString const &,::QString const & ) ;
            removeEquation_function_type removeEquation_function_value( &::SireCAS::LambdaSchedule::removeEquation );
            
            LambdaSchedule_exposer.def( 
                "removeEquation"
                , removeEquation_function_value
                , ( bp::arg("stage"), bp::arg("lever") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeLever
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeLever_function_type)( ::QString const & ) ;
            removeLever_function_type removeLever_function_value( &::SireCAS::LambdaSchedule::removeLever );
            
            LambdaSchedule_exposer.def( 
                "removeLever"
                , removeLever_function_value
                , ( bp::arg("lever") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::removeLevers
        
            typedef void ( ::SireCAS::LambdaSchedule::*removeLevers_function_type)( ::QStringList const & ) ;
            removeLevers_function_type removeLevers_function_value( &::SireCAS::LambdaSchedule::removeLevers );
            
            LambdaSchedule_exposer.def( 
                "removeLevers"
                , removeLevers_function_value
                , ( bp::arg("levers") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setConstant
        
            typedef ::SireCAS::Symbol ( ::SireCAS::LambdaSchedule::*setConstant_function_type)( ::QString const &,double ) ;
            setConstant_function_type setConstant_function_value( &::SireCAS::LambdaSchedule::setConstant );
            
            LambdaSchedule_exposer.def( 
                "setConstant"
                , setConstant_function_value
                , ( bp::arg("constant"), bp::arg("value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setConstant
        
            typedef ::SireCAS::Symbol ( ::SireCAS::LambdaSchedule::*setConstant_function_type)( ::SireCAS::Symbol const &,double ) ;
            setConstant_function_type setConstant_function_value( &::SireCAS::LambdaSchedule::setConstant );
            
            LambdaSchedule_exposer.def( 
                "setConstant"
                , setConstant_function_value
                , ( bp::arg("constant"), bp::arg("value") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setDefaultEquation
        
            typedef void ( ::SireCAS::LambdaSchedule::*setDefaultEquation_function_type)( ::QString const &,::SireCAS::Expression const & ) ;
            setDefaultEquation_function_type setDefaultEquation_function_value( &::SireCAS::LambdaSchedule::setDefaultEquation );
            
            LambdaSchedule_exposer.def( 
                "setDefaultEquation"
                , setDefaultEquation_function_value
                , ( bp::arg("stage"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::setEquation
        
            typedef void ( ::SireCAS::LambdaSchedule::*setEquation_function_type)( ::QString const &,::QString const &,::SireCAS::Expression const & ) ;
            setEquation_function_type setEquation_function_value( &::SireCAS::LambdaSchedule::setEquation );
            
            LambdaSchedule_exposer.def( 
                "setEquation"
                , setEquation_function_value
                , ( bp::arg("stage"), bp::arg("lever"), bp::arg("equation") )
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::toString
        
            typedef ::QString ( ::SireCAS::LambdaSchedule::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireCAS::LambdaSchedule::toString );
            
            LambdaSchedule_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireCAS::LambdaSchedule::typeName );
            
            LambdaSchedule_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        { //::SireCAS::LambdaSchedule::what
        
            typedef char const * ( ::SireCAS::LambdaSchedule::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireCAS::LambdaSchedule::what );
            
            LambdaSchedule_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "" );
        
        }
        LambdaSchedule_exposer.staticmethod( "final" );
        LambdaSchedule_exposer.staticmethod( "initial" );
        LambdaSchedule_exposer.staticmethod( "lam" );
        LambdaSchedule_exposer.staticmethod( "typeName" );
        LambdaSchedule_exposer.def( "__copy__", &__copy__);
        LambdaSchedule_exposer.def( "__deepcopy__", &__copy__);
        LambdaSchedule_exposer.def( "clone", &__copy__);
        LambdaSchedule_exposer.def( "__rlshift__", &__rlshift__QDataStream< ::SireCAS::LambdaSchedule >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        LambdaSchedule_exposer.def( "__rrshift__", &__rrshift__QDataStream< ::SireCAS::LambdaSchedule >,
                            bp::return_internal_reference<1, bp::with_custodian_and_ward<1,2> >() );
        LambdaSchedule_exposer.def_pickle(sire_pickle_suite< ::SireCAS::LambdaSchedule >());
        LambdaSchedule_exposer.def( "__str__", &__str__< ::SireCAS::LambdaSchedule > );
        LambdaSchedule_exposer.def( "__repr__", &__str__< ::SireCAS::LambdaSchedule > );
    }

}

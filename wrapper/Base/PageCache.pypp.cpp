// This file has been generated by Py++.

// (C) Christopher Woods, GPL >= 3 License

#include "boost/python.hpp"
#include "PageCache.pypp.hpp"

namespace bp = boost::python;

#include "SireBase/console.h"

#include "SireBase/parallel.h"

#include "SireError/errors.h"

#include "pagecache.h"

#include <QAtomicInt>

#include <QDir>

#include <QHash>

#include <QMutex>

#include <QQueue>

#include <QTemporaryDir>

#include <QTemporaryFile>

#include <QThread>

#include <boost/noncopyable.hpp>

#include "pagecache.h"

SireBase::PageCache __copy__(const SireBase::PageCache &other){ return SireBase::PageCache(other); }

#include "Helpers/copy.hpp"

const char* pvt_get_name(const SireBase::PageCache&){ return "SireBase::PageCache";}

#include "Helpers/release_gil_policy.hpp"

#include "SireBase/console.h"

#include "SireBase/parallel.h"

#include "SireError/errors.h"

#include "pagecache.h"

#include <QAtomicInt>

#include <QDir>

#include <QHash>

#include <QMutex>

#include <QQueue>

#include <QTemporaryDir>

#include <QTemporaryFile>

#include <QThread>

#include <boost/noncopyable.hpp>

#include "pagecache.h"

SireBase::PageCache::Handle __copy__(const SireBase::PageCache::Handle &other){ return SireBase::PageCache::Handle(other); }

#include "Helpers/copy.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

#include "SireBase/console.h"

#include "SireBase/parallel.h"

#include "SireError/errors.h"

#include "pagecache.h"

#include <QAtomicInt>

#include <QDir>

#include <QHash>

#include <QMutex>

#include <QQueue>

#include <QTemporaryDir>

#include <QTemporaryFile>

#include <QThread>

#include <boost/noncopyable.hpp>

#include "pagecache.h"

SireBase::PageCache::Page __copy__(const SireBase::PageCache::Page &other){ return SireBase::PageCache::Page(other); }

#include "Helpers/copy.hpp"

#include "Helpers/str.hpp"

#include "Helpers/release_gil_policy.hpp"

#include "Helpers/len.hpp"

void register_PageCache_class(){

    { //::SireBase::PageCache
        typedef bp::class_< SireBase::PageCache > PageCache_exposer_t;
        PageCache_exposer_t PageCache_exposer = PageCache_exposer_t( "PageCache", "This class manages a swap cache of binary data that can be\npaged to and from disk. The cache can receive binary data\nof any size, and will automatically manage the paging of\nthat data to and from disk as it is accessed.\n\nYou can create different caches, and have control over the maximum\nsize of each cache page.\n\nNote that deleting the cache will delete all data contained\ntherein - including data paged to disk\n", bp::init< >("Construct a new page cache with the default\n  recomended maximum page size") );
        bp::scope PageCache_scope( PageCache_exposer );
        { //::SireBase::PageCache::Handle
            typedef bp::class_< SireBase::PageCache::Handle > Handle_exposer_t;
            Handle_exposer_t Handle_exposer = Handle_exposer_t( "Handle", "This is a handle to a piece of data that has\nbeen added to the cache. This will either contain\nthe actual data, or will hold the information\nnecessary to retrieve that data from disk.\n\nData is removed from the cache when all handles\nto it are deleted\n", bp::init< >("Construct an empty handle") );
            bp::scope Handle_scope( Handle_exposer );
            Handle_exposer.def( bp::init< std::shared_ptr< SireBase::detail::HandleData > >(( bp::arg("data") ), "Construct a handle from the passed data") );
            Handle_exposer.def( bp::init< SireBase::PageCache::Handle const & >(( bp::arg("other") ), "Copy constructor") );
            { //::SireBase::PageCache::Handle::assertValid
            
                typedef void ( ::SireBase::PageCache::Handle::*assertValid_function_type)(  ) const;
                assertValid_function_type assertValid_function_value( &::SireBase::PageCache::Handle::assertValid );
                
                Handle_exposer.def( 
                    "assertValid"
                    , assertValid_function_value
                    , bp::release_gil_policy()
                    , "Assert that this object is valid" );
            
            }
            { //::SireBase::PageCache::Handle::clear
            
                typedef void ( ::SireBase::PageCache::Handle::*clear_function_type)(  ) ;
                clear_function_type clear_function_value( &::SireBase::PageCache::Handle::clear );
                
                Handle_exposer.def( 
                    "clear"
                    , clear_function_value
                    , bp::release_gil_policy()
                    , "Clear the data from this handle" );
            
            }
            { //::SireBase::PageCache::Handle::fetch
            
                typedef ::QByteArray ( ::SireBase::PageCache::Handle::*fetch_function_type)(  ) const;
                fetch_function_type fetch_function_value( &::SireBase::PageCache::Handle::fetch );
                
                Handle_exposer.def( 
                    "fetch"
                    , fetch_function_value
                    , bp::release_gil_policy()
                    , "Return the data held in this handle" );
            
            }
            { //::SireBase::PageCache::Handle::isNull
            
                typedef bool ( ::SireBase::PageCache::Handle::*isNull_function_type)(  ) const;
                isNull_function_type isNull_function_value( &::SireBase::PageCache::Handle::isNull );
                
                Handle_exposer.def( 
                    "isNull"
                    , isNull_function_value
                    , bp::release_gil_policy()
                    , "Return whether this handle is null (does not hold data)" );
            
            }
            { //::SireBase::PageCache::Handle::isValid
            
                typedef bool ( ::SireBase::PageCache::Handle::*isValid_function_type)(  ) const;
                isValid_function_type isValid_function_value( &::SireBase::PageCache::Handle::isValid );
                
                Handle_exposer.def( 
                    "isValid"
                    , isValid_function_value
                    , bp::release_gil_policy()
                    , "Return whether this handle is valid (holds data)" );
            
            }
            { //::SireBase::PageCache::Handle::nBytes
            
                typedef unsigned int ( ::SireBase::PageCache::Handle::*nBytes_function_type)(  ) const;
                nBytes_function_type nBytes_function_value( &::SireBase::PageCache::Handle::nBytes );
                
                Handle_exposer.def( 
                    "nBytes"
                    , nBytes_function_value
                    , bp::release_gil_policy()
                    , "Return the number of bytes in this handle" );
            
            }
            { //::SireBase::PageCache::Handle::operator=
            
                typedef ::SireBase::PageCache::Handle & ( ::SireBase::PageCache::Handle::*assign_function_type)( ::SireBase::PageCache::Handle const & ) ;
                assign_function_type assign_function_value( &::SireBase::PageCache::Handle::operator= );
                
                Handle_exposer.def( 
                    "assign"
                    , assign_function_value
                    , ( bp::arg("other") )
                    , bp::return_self< >()
                    , "" );
            
            }
            { //::SireBase::PageCache::Handle::page
            
                typedef ::SireBase::PageCache::Page ( ::SireBase::PageCache::Handle::*page_function_type)(  ) const;
                page_function_type page_function_value( &::SireBase::PageCache::Handle::page );
                
                Handle_exposer.def( 
                    "page"
                    , page_function_value
                    , bp::release_gil_policy()
                    , "Return the page on which the data for this handle is placed.\n  This will be null if the data has not yet been put on a page\n" );
            
            }
            { //::SireBase::PageCache::Handle::parent
            
                typedef ::SireBase::PageCache ( ::SireBase::PageCache::Handle::*parent_function_type)(  ) const;
                parent_function_type parent_function_value( &::SireBase::PageCache::Handle::parent );
                
                Handle_exposer.def( 
                    "parent"
                    , parent_function_value
                    , bp::release_gil_policy()
                    , "Return the parent cache for this handle" );
            
            }
            { //::SireBase::PageCache::Handle::reset
            
                typedef void ( ::SireBase::PageCache::Handle::*reset_function_type)(  ) ;
                reset_function_type reset_function_value( &::SireBase::PageCache::Handle::reset );
                
                Handle_exposer.def( 
                    "reset"
                    , reset_function_value
                    , bp::release_gil_policy()
                    , "Clear the data in this handle" );
            
            }
            { //::SireBase::PageCache::Handle::size
            
                typedef unsigned int ( ::SireBase::PageCache::Handle::*size_function_type)(  ) const;
                size_function_type size_function_value( &::SireBase::PageCache::Handle::size );
                
                Handle_exposer.def( 
                    "size"
                    , size_function_value
                    , bp::release_gil_policy()
                    , "Return the number of bytes in this handle" );
            
            }
            { //::SireBase::PageCache::Handle::toString
            
                typedef ::QString ( ::SireBase::PageCache::Handle::*toString_function_type)(  ) const;
                toString_function_type toString_function_value( &::SireBase::PageCache::Handle::toString );
                
                Handle_exposer.def( 
                    "toString"
                    , toString_function_value
                    , bp::release_gil_policy()
                    , "Return a string representation of this object" );
            
            }
            { //::SireBase::PageCache::Handle::typeName
            
                typedef char const * ( *typeName_function_type )(  );
                typeName_function_type typeName_function_value( &::SireBase::PageCache::Handle::typeName );
                
                Handle_exposer.def( 
                    "typeName"
                    , typeName_function_value
                    , bp::release_gil_policy()
                    , "Return the type name for this object" );
            
            }
            { //::SireBase::PageCache::Handle::what
            
                typedef char const * ( ::SireBase::PageCache::Handle::*what_function_type)(  ) const;
                what_function_type what_function_value( &::SireBase::PageCache::Handle::what );
                
                Handle_exposer.def( 
                    "what"
                    , what_function_value
                    , bp::release_gil_policy()
                    , "Return the type name for this object" );
            
            }
            Handle_exposer.staticmethod( "typeName" );
            Handle_exposer.def( "__copy__", &__copy__<SireBase::PageCache::Handle>);
            Handle_exposer.def( "__deepcopy__", &__copy__<SireBase::PageCache::Handle>);
            Handle_exposer.def( "clone", &__copy__<SireBase::PageCache::Handle>);
            Handle_exposer.def( "__str__", &__str__< ::SireBase::PageCache::Handle > );
            Handle_exposer.def( "__repr__", &__str__< ::SireBase::PageCache::Handle > );
            Handle_exposer.def( "__len__", &__len_size< ::SireBase::PageCache::Handle > );
        }
        { //::SireBase::PageCache::Page
            typedef bp::class_< SireBase::PageCache::Page > Page_exposer_t;
            Page_exposer_t Page_exposer = Page_exposer_t( "Page", "This is a page in the cache. This can hold multiple\nobjects - the whole page is either resident in memory\nor cached to disk.\n", bp::init< >("Construct an empty page") );
            bp::scope Page_scope( Page_exposer );
            Page_exposer.def( bp::init< std::shared_ptr< SireBase::detail::PageData > >(( bp::arg("data") ), "Construct a page from the passed data") );
            Page_exposer.def( bp::init< SireBase::PageCache::Page const & >(( bp::arg("other") ), "Copy constructor") );
            { //::SireBase::PageCache::Page::assertValid
            
                typedef void ( ::SireBase::PageCache::Page::*assertValid_function_type)(  ) const;
                assertValid_function_type assertValid_function_value( &::SireBase::PageCache::Page::assertValid );
                
                Page_exposer.def( 
                    "assertValid"
                    , assertValid_function_value
                    , bp::release_gil_policy()
                    , "Assert that this object is valid" );
            
            }
            { //::SireBase::PageCache::Page::isCached
            
                typedef bool ( ::SireBase::PageCache::Page::*isCached_function_type)(  ) const;
                isCached_function_type isCached_function_value( &::SireBase::PageCache::Page::isCached );
                
                Page_exposer.def( 
                    "isCached"
                    , isCached_function_value
                    , bp::release_gil_policy()
                    , "Return whether this page is cached to disk" );
            
            }
            { //::SireBase::PageCache::Page::isNull
            
                typedef bool ( ::SireBase::PageCache::Page::*isNull_function_type)(  ) const;
                isNull_function_type isNull_function_value( &::SireBase::PageCache::Page::isNull );
                
                Page_exposer.def( 
                    "isNull"
                    , isNull_function_value
                    , bp::release_gil_policy()
                    , "Return whether this page is null (has no size)" );
            
            }
            { //::SireBase::PageCache::Page::isResident
            
                typedef bool ( ::SireBase::PageCache::Page::*isResident_function_type)(  ) const;
                isResident_function_type isResident_function_value( &::SireBase::PageCache::Page::isResident );
                
                Page_exposer.def( 
                    "isResident"
                    , isResident_function_value
                    , bp::release_gil_policy()
                    , "Return whether this page is resident in memory" );
            
            }
            { //::SireBase::PageCache::Page::isValid
            
                typedef bool ( ::SireBase::PageCache::Page::*isValid_function_type)(  ) const;
                isValid_function_type isValid_function_value( &::SireBase::PageCache::Page::isValid );
                
                Page_exposer.def( 
                    "isValid"
                    , isValid_function_value
                    , bp::release_gil_policy()
                    , "Return whether this page is valid (has some size)" );
            
            }
            { //::SireBase::PageCache::Page::maxBytes
            
                typedef unsigned int ( ::SireBase::PageCache::Page::*maxBytes_function_type)(  ) const;
                maxBytes_function_type maxBytes_function_value( &::SireBase::PageCache::Page::maxBytes );
                
                Page_exposer.def( 
                    "maxBytes"
                    , maxBytes_function_value
                    , bp::release_gil_policy()
                    , "Return the maximum number of bytes that can be stored in this page" );
            
            }
            { //::SireBase::PageCache::Page::nBytes
            
                typedef unsigned int ( ::SireBase::PageCache::Page::*nBytes_function_type)(  ) const;
                nBytes_function_type nBytes_function_value( &::SireBase::PageCache::Page::nBytes );
                
                Page_exposer.def( 
                    "nBytes"
                    , nBytes_function_value
                    , bp::release_gil_policy()
                    , "Return the number of bytes in this page" );
            
            }
            { //::SireBase::PageCache::Page::operator=
            
                typedef ::SireBase::PageCache::Page & ( ::SireBase::PageCache::Page::*assign_function_type)( ::SireBase::PageCache::Page const & ) ;
                assign_function_type assign_function_value( &::SireBase::PageCache::Page::operator= );
                
                Page_exposer.def( 
                    "assign"
                    , assign_function_value
                    , ( bp::arg("other") )
                    , bp::return_self< >()
                    , "" );
            
            }
            { //::SireBase::PageCache::Page::parent
            
                typedef ::SireBase::PageCache ( ::SireBase::PageCache::Page::*parent_function_type)(  ) const;
                parent_function_type parent_function_value( &::SireBase::PageCache::Page::parent );
                
                Page_exposer.def( 
                    "parent"
                    , parent_function_value
                    , bp::release_gil_policy()
                    , "Return the parent cache for this page" );
            
            }
            { //::SireBase::PageCache::Page::size
            
                typedef unsigned int ( ::SireBase::PageCache::Page::*size_function_type)(  ) const;
                size_function_type size_function_value( &::SireBase::PageCache::Page::size );
                
                Page_exposer.def( 
                    "size"
                    , size_function_value
                    , bp::release_gil_policy()
                    , "Return the number of bytes in this page" );
            
            }
            { //::SireBase::PageCache::Page::toString
            
                typedef ::QString ( ::SireBase::PageCache::Page::*toString_function_type)(  ) const;
                toString_function_type toString_function_value( &::SireBase::PageCache::Page::toString );
                
                Page_exposer.def( 
                    "toString"
                    , toString_function_value
                    , bp::release_gil_policy()
                    , "Return a string representation of this object" );
            
            }
            { //::SireBase::PageCache::Page::typeName
            
                typedef char const * ( *typeName_function_type )(  );
                typeName_function_type typeName_function_value( &::SireBase::PageCache::Page::typeName );
                
                Page_exposer.def( 
                    "typeName"
                    , typeName_function_value
                    , bp::release_gil_policy()
                    , "Return the type name for this object" );
            
            }
            { //::SireBase::PageCache::Page::what
            
                typedef char const * ( ::SireBase::PageCache::Page::*what_function_type)(  ) const;
                what_function_type what_function_value( &::SireBase::PageCache::Page::what );
                
                Page_exposer.def( 
                    "what"
                    , what_function_value
                    , bp::release_gil_policy()
                    , "Return the type name for this object" );
            
            }
            Page_exposer.staticmethod( "typeName" );
            Page_exposer.def( "__copy__", &__copy__<SireBase::PageCache::Page>);
            Page_exposer.def( "__deepcopy__", &__copy__<SireBase::PageCache::Page>);
            Page_exposer.def( "clone", &__copy__<SireBase::PageCache::Page>);
            Page_exposer.def( "__str__", &__str__< ::SireBase::PageCache::Page > );
            Page_exposer.def( "__repr__", &__str__< ::SireBase::PageCache::Page > );
            Page_exposer.def( "__len__", &__len_size< ::SireBase::PageCache::Page > );
        }
        PageCache_exposer.def( bp::init< QString const & >(( bp::arg("cache_dir") ), "Construct a new page cache with specified cache directory\nand recomended maximum page size") );
        PageCache_exposer.def( bp::init< unsigned int >(( bp::arg("max_page_size") ), "Construct a new page cache with the specified\nrecomended maximum page size") );
        PageCache_exposer.def( bp::init< QString const &, unsigned int >(( bp::arg("cache_dir"), bp::arg("max_page_size") ), "Construct a new page cache with the specified\nrecomended maximum page size and cache directory\ntemplate (using QTemporaryDir format)") );
        PageCache_exposer.def( bp::init< std::shared_ptr< SireBase::detail::CacheData > >(( bp::arg("data") ), "Internal constructor used to construct from a CacheData") );
        PageCache_exposer.def( bp::init< SireBase::PageCache const & >(( bp::arg("other") ), "Copy constructor") );
        { //::SireBase::PageCache::assertValid
        
            typedef void ( ::SireBase::PageCache::*assertValid_function_type)(  ) const;
            assertValid_function_type assertValid_function_value( &::SireBase::PageCache::assertValid );
            
            PageCache_exposer.def( 
                "assertValid"
                , assertValid_function_value
                , bp::release_gil_policy()
                , "Assert that this object is valid" );
        
        }
        { //::SireBase::PageCache::cacheDir
        
            typedef ::QString ( ::SireBase::PageCache::*cacheDir_function_type)(  ) const;
            cacheDir_function_type cacheDir_function_value( &::SireBase::PageCache::cacheDir );
            
            PageCache_exposer.def( 
                "cacheDir"
                , cacheDir_function_value
                , bp::release_gil_policy()
                , "Return the cache directory for this cache" );
        
        }
        { //::SireBase::PageCache::getStatistics
        
            typedef ::QString ( *getStatistics_function_type )(  );
            getStatistics_function_type getStatistics_function_value( &::SireBase::PageCache::getStatistics );
            
            PageCache_exposer.def( 
                "getStatistics"
                , getStatistics_function_value
                , bp::release_gil_policy()
                , "Return the statistics for all caches" );
        
        }
        { //::SireBase::PageCache::isNull
        
            typedef bool ( ::SireBase::PageCache::*isNull_function_type)(  ) const;
            isNull_function_type isNull_function_value( &::SireBase::PageCache::isNull );
            
            PageCache_exposer.def( 
                "isNull"
                , isNull_function_value
                , bp::release_gil_policy()
                , "Return whether or not this cache is null" );
        
        }
        { //::SireBase::PageCache::isValid
        
            typedef bool ( ::SireBase::PageCache::*isValid_function_type)(  ) const;
            isValid_function_type isValid_function_value( &::SireBase::PageCache::isValid );
            
            PageCache_exposer.def( 
                "isValid"
                , isValid_function_value
                , bp::release_gil_policy()
                , "Return whether or not this cache is valid" );
        
        }
        { //::SireBase::PageCache::maxPageSize
        
            typedef unsigned int ( *maxPageSize_function_type )(  );
            maxPageSize_function_type maxPageSize_function_value( &::SireBase::PageCache::maxPageSize );
            
            PageCache_exposer.def( 
                "maxPageSize"
                , maxPageSize_function_value
                , bp::release_gil_policy()
                , "Return the current recommend maximum page size" );
        
        }
        { //::SireBase::PageCache::maxResidentPages
        
            typedef unsigned int ( *maxResidentPages_function_type )(  );
            maxResidentPages_function_type maxResidentPages_function_value( &::SireBase::PageCache::maxResidentPages );
            
            PageCache_exposer.def( 
                "maxResidentPages"
                , maxResidentPages_function_value
                , bp::release_gil_policy()
                , "Return the maximum number of resident pages per cache" );
        
        }
        { //::SireBase::PageCache::nBytes
        
            typedef unsigned int ( ::SireBase::PageCache::*nBytes_function_type)(  ) const;
            nBytes_function_type nBytes_function_value( &::SireBase::PageCache::nBytes );
            
            PageCache_exposer.def( 
                "nBytes"
                , nBytes_function_value
                , bp::release_gil_policy()
                , "Return the number of bytes saved in this cache" );
        
        }
        { //::SireBase::PageCache::nPages
        
            typedef unsigned int ( ::SireBase::PageCache::*nPages_function_type)(  ) const;
            nPages_function_type nPages_function_value( &::SireBase::PageCache::nPages );
            
            PageCache_exposer.def( 
                "nPages"
                , nPages_function_value
                , bp::release_gil_policy()
                , "Return the number of pages in this cache" );
        
        }
        { //::SireBase::PageCache::operator=
        
            typedef ::SireBase::PageCache & ( ::SireBase::PageCache::*assign_function_type)( ::SireBase::PageCache const & ) ;
            assign_function_type assign_function_value( &::SireBase::PageCache::operator= );
            
            PageCache_exposer.def( 
                "assign"
                , assign_function_value
                , ( bp::arg("other") )
                , bp::return_self< >()
                , "" );
        
        }
        { //::SireBase::PageCache::pageSize
        
            typedef unsigned int ( ::SireBase::PageCache::*pageSize_function_type)(  ) const;
            pageSize_function_type pageSize_function_value( &::SireBase::PageCache::pageSize );
            
            PageCache_exposer.def( 
                "pageSize"
                , pageSize_function_value
                , bp::release_gil_policy()
                , "Return the suggested maximum page size for this cache" );
        
        }
        { //::SireBase::PageCache::setMaxPageSize
        
            typedef void ( *setMaxPageSize_function_type )( unsigned int,bool );
            setMaxPageSize_function_type setMaxPageSize_function_value( &::SireBase::PageCache::setMaxPageSize );
            
            PageCache_exposer.def( 
                "setMaxPageSize"
                , setMaxPageSize_function_value
                , ( bp::arg("max_page_size"), bp::arg("update_existing")=(bool)(false) )
                , "Set the default maximum page cache size for all new created\n  caches that dont specify it themselves" );
        
        }
        { //::SireBase::PageCache::setMaxResidentPages
        
            typedef void ( *setMaxResidentPages_function_type )( unsigned int );
            setMaxResidentPages_function_type setMaxResidentPages_function_value( &::SireBase::PageCache::setMaxResidentPages );
            
            PageCache_exposer.def( 
                "setMaxResidentPages"
                , setMaxResidentPages_function_value
                , ( bp::arg("n_pages") )
                , bp::release_gil_policy()
                , "Set the maximum number of resident pages per cache" );
        
        }
        { //::SireBase::PageCache::size
        
            typedef unsigned int ( ::SireBase::PageCache::*size_function_type)(  ) const;
            size_function_type size_function_value( &::SireBase::PageCache::size );
            
            PageCache_exposer.def( 
                "size"
                , size_function_value
                , bp::release_gil_policy()
                , "Return the number of bytes saved in this cache" );
        
        }
        { //::SireBase::PageCache::store
        
            typedef ::SireBase::PageCache::Handle ( ::SireBase::PageCache::*store_function_type)( ::QByteArray const & ) ;
            store_function_type store_function_value( &::SireBase::PageCache::store );
            
            PageCache_exposer.def( 
                "store"
                , store_function_value
                , ( bp::arg("data") )
                , bp::release_gil_policy()
                , "Store the data in the cache, returning a handle to the data" );
        
        }
        { //::SireBase::PageCache::toString
        
            typedef ::QString ( ::SireBase::PageCache::*toString_function_type)(  ) const;
            toString_function_type toString_function_value( &::SireBase::PageCache::toString );
            
            PageCache_exposer.def( 
                "toString"
                , toString_function_value
                , bp::release_gil_policy()
                , "Return a string representation of this object" );
        
        }
        { //::SireBase::PageCache::typeName
        
            typedef char const * ( *typeName_function_type )(  );
            typeName_function_type typeName_function_value( &::SireBase::PageCache::typeName );
            
            PageCache_exposer.def( 
                "typeName"
                , typeName_function_value
                , bp::release_gil_policy()
                , "Return the type name for this object" );
        
        }
        { //::SireBase::PageCache::what
        
            typedef char const * ( ::SireBase::PageCache::*what_function_type)(  ) const;
            what_function_type what_function_value( &::SireBase::PageCache::what );
            
            PageCache_exposer.def( 
                "what"
                , what_function_value
                , bp::release_gil_policy()
                , "Return the type name for this object" );
        
        }
        PageCache_exposer.staticmethod( "getStatistics" );
        PageCache_exposer.staticmethod( "maxPageSize" );
        PageCache_exposer.staticmethod( "maxResidentPages" );
        PageCache_exposer.staticmethod( "setMaxPageSize" );
        PageCache_exposer.staticmethod( "setMaxResidentPages" );
        PageCache_exposer.staticmethod( "typeName" );
        PageCache_exposer.def( "__copy__", &__copy__<SireBase::PageCache>);
        PageCache_exposer.def( "__deepcopy__", &__copy__<SireBase::PageCache>);
        PageCache_exposer.def( "clone", &__copy__<SireBase::PageCache>);
        PageCache_exposer.def( "__str__", &pvt_get_name);
        PageCache_exposer.def( "__repr__", &pvt_get_name);
    }

}
